import{a as B}from"./store.47891479.js";const v=(e,t)=>t.some(n=>e instanceof n);let m,p;function E(){return m||(m=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function j(){return p||(p=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const I=new WeakMap,y=new WeakMap,S=new WeakMap,f=new WeakMap,h=new WeakMap;function M(e){const t=new Promise((n,o)=>{const s=()=>{e.removeEventListener("success",a),e.removeEventListener("error",r)},a=()=>{n(l(e.result)),s()},r=()=>{o(e.error),s()};e.addEventListener("success",a),e.addEventListener("error",r)});return t.then(n=>{n instanceof IDBCursor&&I.set(n,e)}).catch(()=>{}),h.set(t,e),t}function L(e){if(y.has(e))return;const t=new Promise((n,o)=>{const s=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",r),e.removeEventListener("abort",r)},a=()=>{n(),s()},r=()=>{o(e.error||new DOMException("AbortError","AbortError")),s()};e.addEventListener("complete",a),e.addEventListener("error",r),e.addEventListener("abort",r)});y.set(e,t)}let w={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return y.get(e);if(t==="objectStoreNames")return e.objectStoreNames||S.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return l(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function A(e){w=e(w)}function C(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...n){const o=e.call(b(this),t,...n);return S.set(o,t.sort?t.sort():[t]),l(o)}:j().includes(e)?function(...t){return e.apply(b(this),t),l(I.get(this))}:function(...t){return l(e.apply(b(this),t))}}function P(e){return typeof e=="function"?C(e):(e instanceof IDBTransaction&&L(e),v(e,E())?new Proxy(e,w):e)}function l(e){if(e instanceof IDBRequest)return M(e);if(f.has(e))return f.get(e);const t=P(e);return t!==e&&(f.set(e,t),h.set(t,e)),t}const b=e=>h.get(e);function V(e,t,{blocked:n,upgrade:o,blocking:s,terminated:a}={}){const r=indexedDB.open(e,t),i=l(r);return o&&r.addEventListener("upgradeneeded",c=>{o(l(r.result),c.oldVersion,c.newVersion,l(r.transaction),c)}),n&&r.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),i.then(c=>{a&&c.addEventListener("close",()=>a()),s&&c.addEventListener("versionchange",u=>s(u.oldVersion,u.newVersion,u))}).catch(()=>{}),i}const T=["get","getKey","getAll","getAllKeys","count"],O=["put","add","delete","clear"],g=new Map;function D(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(g.get(t))return g.get(t);const n=t.replace(/FromIndex$/,""),o=t!==n,s=O.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(s||T.includes(n)))return;const a=async function(r,...i){const c=this.transaction(r,s?"readwrite":"readonly");let u=c.store;return o&&(u=u.index(i.shift())),(await Promise.all([u[n](...i),s&&c.done]))[0]};return g.set(t,a),a}A(e=>({...e,get:(t,n,o)=>D(t,n)||e.get(t,n,o),has:(t,n)=>!!D(t,n)||e.has(t,n)}));async function d(){return await V("Language",3,{upgrade(e,t,n,o,s){t<1?(e.createObjectStore("vocables"),e.createObjectStore("categories",{keyPath:"title"})):t<3&&o.objectStore("vocables").getAll().then(a=>a.forEach(r=>{o.objectStore("vocables").put({lang1:r.lang1,lang2:r.lang2,category:r.category,level:0},r.lang1)}))}})}async function W(e,t){const n=await d(),o=n.transaction(["vocables","categories"],"readwrite"),s=o.objectStore("vocables");s.clear();const a=o.objectStore("categories");a.clear();for(const r of e){await a.put({title:r.title,visible:t.includes(r.title)});for(const i of Object.keys(r.values))await s.put({lang1:i,lang2:r.values[i],category:r.title,level:0},i)}o.commit(),n.close(),B.set(t.length>0)}async function k(){return(await(await d()).transaction("categories","readonly").store.getAll()).filter(n=>n.visible).map(n=>n.title)}async function F(){return(await k()).length>0}async function N(){const t=(await d()).transaction(["vocables","categories"],"readonly"),n=await(await t.objectStore("categories").getAll()).filter(o=>o.visible).map(o=>o.title);return(await t.objectStore("vocables").getAll()).filter(o=>n.includes(o.category)).sort((o,s)=>o.level-s.level)}async function K(e){await(await d()).transaction("vocables","readwrite").store.put(e,e.lang1)}export{F as a,k as b,W as c,N as g,K as s};
